##
# Master Docker Node definition file
#
# This file contains a map (keyed list) of "nodes"
#
# NODE
#
# A node is can be though of as a service definition, which can produce a set of container
# instances for that service; although a node can also produce only a docker build, or a
# volume container, neither of which produce running containers.
#
# NODE TYPES:
#
#   - build : this node produces only a docker image build, which can be used as a parent build for other nodes
#   - volume : this node produces a volume container, which can be built and created, but which does not get started
#   - service : this node produces a startable image, which can be used to start a number of instances of a container, in the background
#   - command : this node produces a runnable image, which can be used like a command, runnable in the foreground, which runs using temporary containers
#
# NODE FORMAT:
#
# The format used for a node, combines a small number of paramters for rodo, with the two major
# configuration components from the fsouza docker api, which contains an extensive list of options
# for complete control over builds and execution.
# Originally, we started with a duplication of the docker-compose format, but that would have
# required extensive transformations, and would have limited options.  This was much simpler.
# If you are used to the docker-compose format, then it is recommended that you quickly read up
# on this new format, as it is much more clear about some common uses such as binds and volumes.
#
# {name}:
#   Type: [build|volume|command|service]  // determines if this node should be built/created-destroyed/started-stopped
#   [Optional] Build: path/to/Docker/build  // path to a Dockerfile, if this node needs to be built (not needed if the image needs to be pulled
#
#   [Optional] Requires: // explicitly declare that other nodes is needed by this one
#     - {name}
#     - {name}
#
#     * Currently the Requires concept is kind of abstract.  Each operation takes it's own interpretation.
#         - build assumes that a dependent image must exist (if it is buildable/pullable)
#         - create assumes that a dependent container instance must exist (if it is createable)
#         - start assumes that a dependent container instance must be started (if it is starteable)
#
#   [Optional] Config:  // Docker API config       --> https://github.com/fsouza/go-dockerclient/blob/master/container.go#L177
#   [Optional] Host:    // Docker API host config  --> https://github.com/fsouza/go-dockerclient/blob/master/container.go#L424
#
# TOKENS
#
#  Tokens are string values which are subject to string substitution, before the YAML is marshalled/parsed.
#  The system adds some standard tokens, but mainly they come from:
#     - User ENV variables (from golang os.EnvVariables
#     - #Project# and #Author# are created by the system, and can be overriden in conf.yml
#     - Any Path (like from conf.yml) are converted ::  mycustompath => #PATH_MYCUSTOMPATH#
#     - Custom Tokens from conf.yml:Tokens.  For example mycustomtoken => #mycustomtoken#
#     - Secret tokens from secrets/secrets.yml
#
# In case it isn't clear, the string substitution looks for the token, wrapped in ## characters.  This syntax
# means that failed substitutions don't invalidate the YML, so they don't break the parsing.
#
# DEPENDENCIES
#
# Typically, one node should be able to rely on another node as a dependency.  This can occur for a number
# of reasons:
#   - a node needs the image of it's dependency for it's build
#   - a node links to it's dependency
#   - a node uses a volume from it's dependency
#   - you have decided that it is a dependency (something that we did not think of)
# You can mark a node as a dependency manually, and the code will try to sort out some additional dependencies on
# it's own by looking at links, volumesfrom etc.
#
##

# Files volume container
files:
  Type: volume
  Build: .rodo/docker/files

  Config:
    Volumes:
      "/app/tmp": {}               # /app/tmp is a volatile container folder
  Host:
    Binds:
      - app/assets:/app/assets     # host based assets folder
      - app/backup:/app/backup     # host based archive folder

# Source volume container
source:
  Type: volume
  Build: .rodo/docker/source

  Host:
    Binds:
      - app/www:/app/www          # host based webroots folder (needs /active subroot for nginx conf)

# Database service
db:
  Type: service
  Build: .rodo/docker/db          # DB has a docker build so that we can create databases and set custom passwords.

  Config:
    RestartPolicy: on-failure

    ExposedPorts:
      3306/tcp: {}

  Host:
    VolumesFrom:
      - files                     # I am not sure if this is needed

# FPM service
fpm:
  Type: service

  Config:
    Image: jamesnesbitt/wunder-php6fpm     # The FPM works, and should have blackfire working
    RestartPolicy: on-failure

    ExposedPorts:
      9000/tcp:

  Host:
    Links:
      - db:database.app
    VolumesFrom:
      - files
      - source

# WWW service
www:
  Type: service

  Config:
    Image: jamesnesbitt/wunder-nginx
    RestartPolicy: on-failure

    Hostname: #PROJECT#                 # Token : project name (can be set in conf.yml)
    Domainname: #DOMAIN#                # Token : can be set in conf.yml:Tokens
    Env:
      - DNSDOCK_ALIAS=#PROJECT#.#CONTAINER_DOMAIN#  # If you are using DNSDOCK, this will create a DNS Entry.

    ExposedPorts:
      80/tcp: {}
      443/tcp: {}

  Host:
    Binds:
      - app/www:/app/www
    Links:
      - fpm:fpm.app
    VolumesFrom:
      - files
      - source
    PortBindings:
      80/tcp:
        - HostPort: 8080            # Port 8080 applies to all Host IPs
